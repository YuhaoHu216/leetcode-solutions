# 二叉树

## 遍历

遍历分为两种

1.广度优先遍历：尽可能先访问距离根最近的节点，称为层序遍历

2.深度优先遍历：对于二叉树，可以进一步分成三种(要深入到叶子节点)

​	1.前序遍历，对于每一颗子树，先访问该节点，然后是左子树，最后是右子树

​	2.中序遍历，对于每一棵子树，先访问左子树，然后是该节点，最后是右子树

​	3.后序遍历，对于每一棵子树，先访问左子树，然后是右子树，最后是该节点

无论哪种遍历方式，经过节点的路径都是一样的

### 前序遍历

**递归方式**

```java
static void preOrder(TreeNode node){
    if(node == null){
        return;
    }
    System.out.print(node.val + " ");
    preOrder(node.left);
    preOrder(node.right);
}
```

**非递归**（中序遍历仅是输出位置变化）

```java
LinkedList<TreeNode> stack = new LinkedList<>();
TreeNode curr = root;
while(curr != null || !stack.isEmpty){
    if(curr != null){
        System.out.println("去:" + curr.val);  // 先序遍历
        stack.push(curr); // 入栈，记住回去的路
        curr = curr.left;
    }else{
        TreeNode pop = stack.pop();
        System.out.println("回:" + pop.val); // 中序遍历
		// 切换到右子树
        curr = node.right;
    }
}

```

### 中序遍历

**递归方式**

```java
static void inOrder(TreeNode node){
    if(node == null){
        return;
    }
    inOrder(node.left);
    System.out.print(node.val + " ");
    inOrder(node.right);
}
```

### 后序遍历

**递归方式**

```java
void postOrder(TreeNode node){
    if(node == null){
        return;
    }
    postOrder(node.left);
    postOrder(node.right);
    System.out.print(node.val + " ");
}
```

**非递归方式**

```java
LinkedList<TreeNode> stack = new LinkedList<>();
TreeNode curr = root;
TreeNode pop = null; // 记录最新弹出栈的元素
while(curr != null || !stack.isEmpty){
    if(curr != null){
        System.out.println("去:" + curr.val);
        stack.push(curr); // 入栈，记住回去的路
        curr = curr.left;
    }else{
        TreeNode peek = stack.peek(); // 获取栈顶元素
        if(peek.right == null || peek.right == pop){
        	pop = stack.pop();
        	System.out.println("回:" + pop.val);    
        }else{
            // 切换到右子树
        	curr = peek.right;
        }
    }
}

```

### 非递归统一模板

